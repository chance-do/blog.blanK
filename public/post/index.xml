<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Blank&#39;s Blog</title>
    <link>https://mjyi.github.io/post/index.xml</link>
    <description>Recent content in Posts on Blank&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2008 - 2014, blanK; all rights reserved.</copyright>
    <lastBuildDate>Sun, 12 Mar 2017 17:51:07 +0000</lastBuildDate>
    <atom:link href="https://mjyi.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>vim命令笔记</title>
      <link>https://mjyi.github.io/post/1703-vim/</link>
      <pubDate>Sun, 12 Mar 2017 17:51:07 +0000</pubDate>
      
      <guid>https://mjyi.github.io/post/1703-vim/</guid>
      <description>&lt;h3 id=&#34;基本移动&#34;&gt;基本移动&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;h&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;左&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;j&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;k&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;l&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;右&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;行间跳转&#34;&gt;行间跳转&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;nG&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;移动至&lt;code&gt;n&lt;/code&gt;行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gg&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;移动至第一行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;移动至最后一行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Tip:&lt;/strong&gt; 使用&lt;code&gt;Ctrl+o&lt;/code&gt;快速回到上一次(跳转前)光标所在位置.
&lt;/p&gt;

&lt;h3 id=&#34;行内跳转&#34;&gt;行内跳转&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下一个单词开头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上一个单词开头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下个单词结尾&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ge&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上个单词结尾&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;或&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行尾&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;f&amp;lt;字母&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;向后搜索&amp;lt;字母&amp;gt;并跳转到第一个匹配的位置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;F&amp;lt;字母&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;向前搜索&amp;lt;字母&amp;gt;并跳转到第一个匹配的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;插入模式&#34;&gt;插入模式&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;i&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在当前光标处进行编辑&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在光标后插入编辑&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;I&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在行首插入&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;A&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在行末插入&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;o&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在当前行后插入一个新行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;O&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在当前行前插入一个新行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cw&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;替换从光标所在位置后到一个单词结尾的字符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;保存退出&#34;&gt;保存退出&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;命令行模式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;命令模式下：&lt;code&gt;w&lt;/code&gt; 回车。
输入&lt;code&gt;:w 文件名&lt;/code&gt; 可以将文件另存。或者保存在其他路径。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:q&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;退出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:q!&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;强制退出，不保存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:wq&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;保存退出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:wq!&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;强制保存退出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;保存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:w &amp;lt;文件路径&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;另存为~&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:saveas &amp;lt;文件路径&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;另存为~&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;普通模式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;shift + zz&lt;/code&gt;即可保存退出。&lt;/p&gt;

&lt;h2 id=&#34;删除文本&#34;&gt;删除文本&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除游标所在的字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除游标所在的前一个字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Delete&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同&lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除整行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ndd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除&lt;code&gt;n&lt;/code&gt;行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dw&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除一个单词&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;d$&lt;/code&gt;或&lt;code&gt;D&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除至行尾&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;d^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除至行首&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dG&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除至文档尾部&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dgg&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除至文档首部&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dnG&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除至第&lt;code&gt;n&lt;/code&gt;行(如&lt;code&gt;d1G&lt;/code&gt;：删至首部)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;vim-重复命令&#34;&gt;vim 重复命令&lt;/h2&gt;

&lt;h3 id=&#34;1-重复执行上次命令&#34;&gt;1. 重复执行上次命令&lt;/h3&gt;

&lt;p&gt;普通模式下  &lt;code&gt;.&lt;/code&gt; 表示重复上一次的命令操作。&lt;/p&gt;

&lt;h3 id=&#34;2-执行指定次数相同的命令&#34;&gt;2. 执行指定次数相同的命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;输入&lt;code&gt;10x&lt;/code&gt;，连续删除10个字符。&lt;/li&gt;
&lt;li&gt;输入&lt;code&gt;4dd&lt;/code&gt;, 连续删除4行文本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同样，&lt;code&gt;dw&lt;/code&gt;，&lt;code&gt;daw&lt;/code&gt;(delete a word)，&lt;code&gt;dnw&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;复制粘贴和剪切&#34;&gt;复制粘贴和剪切&lt;/h2&gt;

&lt;h3 id=&#34;复制粘贴&#34;&gt;复制粘贴&lt;/h3&gt;

&lt;p&gt;普通模式下
复制命令| 说明
&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;-
&lt;code&gt;yy&lt;/code&gt; |复制游标所在的整行（3yy表示复制3行）
&lt;code&gt;y^&lt;/code&gt; | 复制至行首，或y0。不含光标所在处字符。
&lt;code&gt;y$&lt;/code&gt; | 复制至行尾。含光所在处字符。
&lt;code&gt;y2w&lt;/code&gt;|复制两个单词。
&lt;code&gt;yG&lt;/code&gt; |复制至文本末。
&lt;code&gt;y1G&lt;/code&gt;|复制至文本开头。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;粘贴命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;p&lt;/code&gt;&amp;lt;小写&amp;gt;&lt;/td&gt;
&lt;td&gt;粘贴至光标后（下）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;P&lt;/code&gt;&amp;lt;大写&amp;gt;&lt;/td&gt;
&lt;td&gt;粘贴至光标前（上）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;剪切&#34;&gt;剪切&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;dd&lt;/code&gt;删除命令就是剪切，你每次&lt;code&gt;dd&lt;/code&gt;删除文档内容后，便可以使用p来粘贴。如&lt;code&gt;ddp&lt;/code&gt;可以交换上下行。&lt;/p&gt;

&lt;!--## 查找替换--&gt;

&lt;p&gt;持续更新！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>记OpenConnect VPN server的搭建</title>
      <link>https://mjyi.github.io/post/1702-ocserv/</link>
      <pubDate>Wed, 15 Feb 2017 17:15:43 +0000</pubDate>
      
      <guid>https://mjyi.github.io/post/1702-ocserv/</guid>
      <description>&lt;p&gt;iphone 上使用VPN 一直是件让人头疼的事。而&lt;code&gt;shadowsocks&lt;/code&gt;的iOS客户端，并不像对其它系统那么“友好”。&lt;/p&gt;

&lt;p&gt;iOS 系统设置支持&lt;code&gt;IKEv2&lt;/code&gt;，&lt;code&gt;IPSec&lt;/code&gt;，&lt;code&gt;L2TP&lt;/code&gt;。但是用起来很“痛苦”，连接慢，爱断线！&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;OpenConnet Server（ocserv）它通过实现Cisco的AnyConnect协议，用DTLS作为主要的加密传输协议。&lt;/p&gt;

&lt;p&gt;AnyConnect的VPN协议默认使用UDP DTLS作为数据传输，但如果有什么网络问题导致UDP传输出现问题，它会利用最初建立的TCP TLS通道作为备份通道，降低VPN断开的概率。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于个人使用，这个优点就够了！！！&lt;/p&gt;

&lt;p&gt;vps:
- Ubuntu 14.04 LTS
- OpenVZ架构
&lt;/p&gt;

&lt;h2 id=&#34;编译ocserv&#34;&gt;编译ocserv&lt;/h2&gt;

&lt;p&gt;首先，我们先下载&lt;code&gt;ocserv&lt;/code&gt;的最新版本.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget ftp://ftp.infradead.org/pub/ocserv/ocserv-0.11.7.tar.xz
tar xvf ocserv-0.11.7.tar.xz
cd ocserv-0.11.7

# 添加编译依赖库。
apt-get install libev-dev  build-essential pkg-config libgnutls28-dev libreadline-dev libseccomp-dev libwrap0-dev libnl-nf-3-dev liblz4-dev

# 编译/安装
```bash
./configure

make  
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置ocserv&#34;&gt;配置ocserv&lt;/h2&gt;

&lt;p&gt;参考&lt;a href=&#34;http://www.infradead.org/ocserv/manual.html&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;证书&#34;&gt;证书&lt;/h3&gt;

&lt;p&gt;安装证书工具 &lt;code&gt;apt-get install gnutls-bin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;证书的配置参考&lt;a href=&#34;http://www.infradead.org/ocserv/manual.html&#34;&gt;官方文档&lt;/a&gt;即可&lt;/p&gt;

&lt;p&gt;** 创建CA证书模板 **&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir certificates
cd certificates

vi ca.tmpl
cn = &amp;quot;Your CA name&amp;quot; 
organization = &amp;quot;Your fancy name&amp;quot; 
serial = 1 
expiration_days = 3650
ca 
signing_key 
cert_signing_key 
crl_signing_key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;** 生成CA密钥 和 证书 **&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;certtool --generate-privkey --outfile ca-key.pem
certtool --generate-self-signed --load-privkey ca-key.pem --template ca.tmpl --outfile ca-cert.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;同样，生成服务器证书&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi server.tmpl
cn = &amp;quot;Your hostname or IP&amp;quot; 
organization = &amp;quot;Your fancy name&amp;quot; 
expiration_days = 3650
signing_key 
encryption_key
tls_www_server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;生成Server密钥 和 证书&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;certtool --generate-privkey --outfile server-key.pem

certtool --generate-certificate --load-privkey server-key.pem --load-ca-certificate ca-cert.pem --load-ca-privkey ca-key.pem --template server.tmpl --outfile server-cert.pem

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将CA，Server证书与密钥复制到以下文件夹&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp ca-cert.pem /etc/ssl/private/my-ca-cert.pem
cp server-cert.pem /etc/ssl/private/my-server-cert.pem
cp server-key.pem /etc/ssl/private/my-server-key.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;下面准备配置文件&#34;&gt;下面准备配置文件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;mkdir /etc/ocserv
cd ~/ocserv*
cp doc/sample.config /etc/ocserv/ocserv.conf
vi /etc/ocserv/ocserv.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件可以&lt;a href=&#34;http://www.infradead.org/ocserv/manual.html&#34;&gt;官方文档&lt;/a&gt;来写，不过这里我们重点要确保以下条目正确。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 登陆方式，目前先用密码登录
auth = &amp;quot;plain[/etc/ocserv/ocpasswd]&amp;quot;

# 允许同时连接的客户端数量
max-clients = 4

# 限制同一客户端的并行登陆数量
max-same-clients = 2

# 服务监听的IP（服务器IP，可不设置）
#listen-host = 1.2.3.4

# 服务监听的TCP/UDP端口（选择你喜欢的数字）
tcp-port = 9000
udp-port = 9001

# 自动优化VPN的网络性能
try-mtu-discovery = true

# 确保服务器正确读取用户证书（后面会用到用户证书）
cert-user-oid = 2.5.4.3

# 服务器证书与密钥
ca-cert = /etc/ssl/private/my-ca-cert.pem
server-cert = /etc/ssl/private/my-server-cert.pem
server-key = /etc/ssl/private/my-server-key.pem

# 客户端连上vpn后使用的dns
dns = 8.8.8.8
dns = 8.8.4.4

# 注释掉所有的route，让服务器成为gateway
#route = 192.168.1.0/255.255.255.0

# 启用cisco客户端兼容性支持
cisco-client-compat = true

#据说可以优化速度
output-buffer = 23000 
try-mtu-discovery = true 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;修改防火墙&#34;&gt;修改防火墙&lt;/h3&gt;

&lt;p&gt;修改内核设置，使得支持转发，&lt;code&gt;vi /etc/sysctl.conf&lt;/code&gt;,将&lt;code&gt;net.ipv4.ip_forward=0&lt;/code&gt;改为&lt;code&gt;net.ipv4.ip_forward=1&lt;/code&gt;
保存生效&lt;code&gt;sysctl -p&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;打开OCserv对应的TCP/UDP端口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -A INPUT -p tcp -m state --state NEW --dport 9000 -j ACCEPT
iptables -A INPUT -p udp -m state --state NEW --dport 9001 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开启NAT转发。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o venet0 -j MASQUERADE
iptables -A FORWARD -s 192.168.1.0/24 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;iptables -t nat -L&lt;/code&gt;来验证转发是否开启成功&lt;/p&gt;

&lt;h3 id=&#34;测试服务器&#34;&gt;测试服务器&lt;/h3&gt;

&lt;p&gt;创建一个帐号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ocpasswd -c /etc/ocserv/ocpasswd username
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ocserv -f -d 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连接手机测试。。。。&lt;/p&gt;

&lt;h3 id=&#34;免密码登录&#34;&gt;免密码登录&lt;/h3&gt;

&lt;p&gt;创建客户端证书，免密码登录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/certificates/
vi user.tmpl

cn = &amp;quot;some random name&amp;quot;
unit = &amp;quot;some random unit&amp;quot;
expiration_days = 365
signing_key
tls_www_client
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;**生成User密钥 生成User证书 **&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;certtool --generate-privkey --outfile user-key.pem

certtool --generate-certificate --load-privkey user-key.pem --load-ca-certificate ca-cert.pem --load-ca-privkey ca-key.pem --template user.tmpl --outfile user-cert.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将证书和密钥转为PKCS12的格式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;certtool --to-p12 --load-privkey user-key.pem --pkcs-cipher 3des-pkcs12 --load-certificate user-cert.pem --outfile user.p12 --outder
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入证书名字和密码。&lt;/p&gt;

&lt;p&gt;可以使用web服务将&lt;code&gt;user.p12&lt;/code&gt;导入手机。&lt;/p&gt;

&lt;p&gt;我用的是python的一个简单http服务器命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/targetfolder
python -m SimpleHTTPServer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用&lt;code&gt;Safari&lt;/code&gt;打开下载。&lt;/p&gt;

&lt;p&gt;** 修改认证方式 **&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /etc/ocserv/ocserv.conf

# 改为证书登陆，注释掉原来的登陆模式
auth = &amp;quot;certificate&amp;quot;

# 证书认证不支持这个选项，注释掉这行
#listen-clear-file = /var/run/ocserv-conn.socket

# 启用证书验证
ca-cert = /etc/ssl/private/my-ca-cert.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，我们可以制作一个启动脚本。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /etc/init.d
ln -s /lib/init/upstart-job ocserv

cd /etc/init
vi  ocserv.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;填入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!upstart
description &amp;quot;OpenConnect Server&amp;quot;

start on runlevel [2345]
stop on runlevel [06]

respawn
respawn limit 20 5

script
    exec start-stop-daemon --start --pidfile /var/run/ocserv.pid --exec /usr/local/sbin/ocserv -- -f &amp;gt;&amp;gt; /dev/null 2&amp;gt;&amp;amp;1
end script
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，我们就可以使用&lt;code&gt;service ocserv start&lt;/code&gt;和&lt;code&gt;service ocserv stop&lt;/code&gt;来控制服务了。&lt;/p&gt;

&lt;p&gt;** 后记：**&lt;/p&gt;

&lt;p&gt;终于能够舒服的看片了！&lt;/p&gt;

&lt;p&gt;iphone 客户端：在&lt;code&gt;APP Store&lt;/code&gt; 搜索&lt;code&gt;AnyConnect&lt;/code&gt;。。
参考：
&lt;a href=&#34;http://www.infradead.org/ocserv/manual.html&#34;&gt;官方文档&lt;/a&gt;
&lt;a href=&#34;https://bitinn.net/11084/&#34;&gt;https://bitinn.net/11084/&lt;/a&gt;
&lt;a href=&#34;https://github.com/iMeiji/shadowsocks_install/wiki/OpenConnect-VPN-server&#34;&gt;OpenConnect VPN server&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>VPS:搭建shadowsocks服务器</title>
      <link>https://mjyi.github.io/post/1702-shadowsocks/</link>
      <pubDate>Tue, 14 Feb 2017 12:33:16 +0000</pubDate>
      
      <guid>https://mjyi.github.io/post/1702-shadowsocks/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks/tree/master&#34;&gt;shadowsocks&lt;/a&gt;有多个版本，目前相对稳定的是&lt;code&gt;python&lt;/code&gt;版本和&lt;code&gt;C&lt;/code&gt;版本(shadowsocks-libev),前者可以通过配置开启多端口，&lt;code&gt;libev&lt;/code&gt;版本不能通过修改配置文件来多端口，只能开启多进程，但是后者占用内存小，cpu消耗少。&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;我的&lt;code&gt;VPS&lt;/code&gt;已经安装好了&lt;code&gt;Ubuntu 14.04 x86&lt;/code&gt;系统，内存&lt;code&gt;512MB&lt;/code&gt;尚可。&lt;/p&gt;

&lt;p&gt;下面来安装&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks/tree/master&#34;&gt;shadowsocks&lt;/a&gt;

通过&lt;code&gt;pip&lt;/code&gt;安装&lt;code&gt;pyhton&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install python-pip
pip install shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一步就卡住了，/尴尬。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Reading package lists... Done
Building dependency tree       
Reading state information... Done
E: Unable to locate package python-pip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget -P Downloads/ https://svn.apache.org/repos/asf/oodt/tools/oodtsite.publisher/trunk/distribute_setup.py

python Downloads/distribute_setup.py

easy_install pip
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ssserver -p 443 -k password -m aes-256-cfb

# 后台运行
sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start

# 停止
sudo ssserver -d stop

# 日志
sudo less /var/log/shadowsocks.log
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用配置文件&#34;&gt;使用配置文件&lt;/h2&gt;

&lt;p&gt;创建 &lt;code&gt;/etc/shadowsocks.json&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;server&amp;quot;:&amp;quot;my_server_ip&amp;quot;,
    &amp;quot;server_port&amp;quot;:8388,
    &amp;quot;local_address&amp;quot;: &amp;quot;127.0.0.1&amp;quot;,
    &amp;quot;local_port&amp;quot;:1080,
    &amp;quot;password&amp;quot;:&amp;quot;mypassword&amp;quot;,
    &amp;quot;timeout&amp;quot;:300,
    &amp;quot;method&amp;quot;:&amp;quot;aes-256-cfb&amp;quot;,
    &amp;quot;fast_open&amp;quot;: false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssserver -c /etc/shadowsocks.json

后台运行
ssserver -c /etc/shadowsocks.json -d start
ssserver -c /etc/shadowsocks.json -d stop
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;至此，&lt;code&gt;shadowsocks&lt;/code&gt;服务器端就搭建完成了。&lt;/p&gt;

&lt;p&gt;附Shadowsocks for OSX下载地址:&lt;a href=&#34;https://sourceforge.net/projects/shadowsocksgui/&#34;&gt;https://sourceforge.net/projects/shadowsocksgui/&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>读:《Objective-C高级编程》之GCD</title>
      <link>https://mjyi.github.io/post/1701-gcd/</link>
      <pubDate>Tue, 17 Jan 2017 14:26:31 +0000</pubDate>
      
      <guid>https://mjyi.github.io/post/1701-gcd/</guid>
      <description>&lt;!-- ![](/uploads/1703.jpg) --&gt;

&lt;h1 id=&#34;什么是gcd&#34;&gt;什么是GCD&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Grand Central Dispatch(GCD)&lt;/code&gt;是异步执任务的技术之一。一般将应用程序中记述的线程管理用的代码在系统级中实现。开发只需要定义想执行并追加到适当的&lt;code&gt;Dispatch Queue&lt;/code&gt; 中，&lt;code&gt;GCD&lt;/code&gt;就能生成必要的线程并计划执行任务，由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可以执行任务，这样就比以前的线程更有效率。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;关于多线程编程&#34;&gt;关于多线程编程&lt;/h1&gt;

&lt;p&gt;线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流。
一个&lt;code&gt;CPU&lt;/code&gt; 一次只能执行一个命令，不能执行某处分开的并列的两个命令。因此通过&lt;code&gt;CPU&lt;/code&gt;执行的&lt;code&gt;CPU命令&lt;/code&gt;就好比一条无分叉的大道，其执行不会出现分歧。

&lt;code&gt;OS X&lt;/code&gt;和&lt;code&gt;iOS&lt;/code&gt;的核心&lt;code&gt;XNU内核&lt;/code&gt;在发生操作系统事件时，会切换执行路径，执行中的状态，例如&lt;code&gt;CPU&lt;/code&gt;的寄存器等信息保存到各自路径专用的内存块中，从切换目标路径专用的内存块中，复原&lt;code&gt;CPU&lt;/code&gt;寄存器等信息，继续执行切换路径的&lt;code&gt;CPU&lt;/code&gt;命令行。这就称为&lt;code&gt;上下文切换&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;由于使用多线程的程序可以在某个线程和其他线程之间反复多次的进行上下文切换，因此看上去就好像1个&lt;code&gt;CPU&lt;/code&gt;核能够并列的执行多个线程一样，而且在具有多个&lt;code&gt;CPU&lt;/code&gt;核的情况下，就是真的提供多个&lt;code&gt;CPU&lt;/code&gt;核并行执行多个线程的技术。&lt;/p&gt;

&lt;p&gt;这种利用多线程编程的技术就称为“多线程编程”。&lt;/p&gt;

&lt;p&gt;但是，多线程编程实际上是一种易发生各种问题的编程技术。比如多个线程更新相同的资源会导致数据的不一致（数据竞争）、停止等待事件的线程会导致多个线程相互持续等待（死锁）、使用太多线程会消耗大量内存等。&lt;/p&gt;

&lt;h1 id=&#34;gcd-的-api&#34;&gt;GCD 的 API&lt;/h1&gt;

&lt;h4 id=&#34;dispatch-queue&#34;&gt;Dispatch Queue&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;dispatch_async(dispatch_queue_t  _Nonnull queue, ^{
   // doSomething     
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Dispatch Queue&lt;/code&gt;, 是执行处理的等待队列。&lt;/p&gt;

&lt;p&gt;使用Block语法定义&lt;code&gt;想执行的任务&lt;/code&gt;，通过&lt;code&gt;dispatch_async&lt;/code&gt;函数追加赋值在变量queue的&lt;code&gt;Dispatch Queue&lt;/code&gt;中。仅这样就可以使指定的&lt;code&gt;Block&lt;/code&gt;在另外一个线程执行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Dispatch Queue&lt;/code&gt;按照FIFO（First-In-First-Out）执行处理。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Dispatch Queue&lt;/code&gt;有两种：&lt;/p&gt;

&lt;p&gt;Dispatch Queue | 说明 |
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;|&amp;mdash;&amp;ndash; |&amp;mdash;&amp;mdash;&amp;mdash;
Serial Dispatch Queue     | 等待现在执行中处理结果     | 使用一个线程
Concurrent Dispatch Queue | 不等的现在执行中处理结果    | 使用多个线程&lt;/p&gt;

&lt;h4 id=&#34;dispatch-queue-create&#34;&gt;dispatch_queue_create&lt;/h4&gt;

&lt;p&gt;通过&lt;code&gt;dispatch_queue_create&lt;/code&gt;生成Dispatch Queue。&lt;/p&gt;

&lt;p&gt;如下生成一个 Serial Dispatch Queue：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;dispatch_queue_create(const char * _Nullable label, dispatch_queue_attr_t  _Nullable attr);

dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create(&amp;quot;com.example.gcd.mySerialDispatchQueue&amp;quot;, NULL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个参数指定&lt;code&gt;Dispatch Queue&lt;/code&gt;的名称，第二个参数指定&lt;code&gt;NULL/DISPATCH_QUEUE_SERIAL&lt;/code&gt; 生成&lt;code&gt;Serial Dispatch Queue&lt;/code&gt;。。生成&lt;code&gt;Concurrent Dispatch Queue&lt;/code&gt;时，将第二个参数指定为&lt;code&gt;DISPATCH_QUEUE_CONCURRENT&lt;/code&gt;，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;dispatch_queue_t myConcurretnDispatchQueue = dispatch_queue_create(&amp;quot;com.example.gcd.myConCurrentDispatchQueue&amp;quot;, DISPATCH_QUEUE_CONCURRENT);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dispatch_queue_create 函数的返回值为表示Dispatch Queuede的 dispatch_queue_t类型。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Serial Dispatch Queue&lt;/code&gt; 一次只能执行一个追加任务。系统对一个&lt;code&gt;Serial Dispatch Queue&lt;/code&gt;只生成一并使用一个线程，如果生成2000个&lt;code&gt;Serial Dispatch Queue&lt;/code&gt;，那么就生成2000个线程。如果过多使用多线程就会消耗大量内存，引起大量的上下文切换，大幅度降低系统的响应性能。&lt;/p&gt;

&lt;p&gt;只在为了避免多线程编程问题之一——多个线程更新相同资源导致数据竞争时，使用&lt;code&gt;Serial Dispatch Queue&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下面分别添加几个block到两个队列中：
Serial Dispatch Queue&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;	dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create(&amp;quot;com.example.gcd.mySerialDispatchQueue&amp;quot;, NULL);
    dispatch_async(mySerialDispatchQueue, ^{ NSLog(@&amp;quot;blcok1&amp;quot;); });
    dispatch_async(mySerialDispatchQueue, ^{ NSLog(@&amp;quot;block2&amp;quot;); });
    dispatch_async(mySerialDispatchQueue, ^{ NSLog(@&amp;quot;block3&amp;quot;); });
    dispatch_async(mySerialDispatchQueue, ^{ NSLog(@&amp;quot;block4&amp;quot;); });
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;2017-01-19 20:23:50.599 gcd[13765:2856357] blcok1
2017-01-19 20:23:50.599 gcd[13765:2856357] block2
2017-01-19 20:23:50.599 gcd[13765:2856357] block3
2017-01-19 20:23:50.599 gcd[13765:2856357] block4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Concurrent Dispatch Queue&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;    dispatch_queue_t myConcurretnDispatchQueue = dispatch_queue_create(&amp;quot;com.example.gcd.myConcurretnDispatchQueue&amp;quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_async(myConcurretnDispatchQueue, ^{ NSLog(@&amp;quot;blcok1&amp;quot;); });
    dispatch_async(myConcurretnDispatchQueue, ^{ NSLog(@&amp;quot;block2&amp;quot;); });
    dispatch_async(myConcurretnDispatchQueue, ^{ NSLog(@&amp;quot;block3&amp;quot;); });
    dispatch_async(myConcurretnDispatchQueue, ^{ NSLog(@&amp;quot;block4&amp;quot;); });
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2017-01-19 20:25:17.937 gcd[13811:2867322] blcok1
2017-01-19 20:25:17.937 gcd[13811:2867323] block3
2017-01-19 20:25:17.937 gcd[13811:2867325] block2
2017-01-19 20:25:17.937 gcd[13811:2867366] block4
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 iOS 6+ 和 Mac OS X 10.8+ ARC 可以管理GCD.在此之前，用下面代码释放gcd&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;dispatch_release(queue);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;main-dispatch-queue-global-dispatch-queue&#34;&gt;Main Dispatch Queue/Global Dispatch Queue&lt;/h4&gt;

&lt;p&gt;Main Dispatch Queue 是在主线程中执行的Dispatch Queue。 是Serial Dispatch Queue。
追加到 Main Dispatch Queue 的处理实在主线程的RunLoop 中执行，由于是在主线程中执行，因此要将用户界面更新等一些必须在主线程中执行的处理追加&lt;code&gt;Main Dispatch Queue&lt;/code&gt;。
Global Dispatch Queue 是所有应用程序能够使用的 Concurrent Dispatch Queue。没必要通过dispatch_queue_create 逐个生成Concurrent Dispatch Queue。只要的Global Dispatch Queue中使用即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;//	Main Dispatch Queue
    dispatch_queue_t mainQueue = dispatch_get_main_queue();
    /*
     * Global Dispatch Queue 优先级从高到低
	 */

    dispatch_queue_t globalQueueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);

    dispatch_queue_t globalQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

    dispatch_queue_t globalQueueLow = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);

    dispatch_queue_t globalQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是最常见的Main Dispatch Queue和Global Dispatch Queue的使用方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;	dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
       /*
        *   可并行的处理
        */
        dispatch_async(dispatch_get_main_queue(), ^{
            //只能在主线程中执行的处理
        });
    });

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dispatch-set-target-queue&#34;&gt;dispatch_set_target_queue&lt;/h4&gt;

&lt;p&gt;dispatch_set_target_queue函数是变更生成的&lt;code&gt;Dispatch Queue&lt;/code&gt;的优先级。&lt;/p&gt;

&lt;p&gt;修改用户队列的目标队列，使多个serial queue在目标queue上一次只有一个执行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt; // dispatch_set_target_queue(&amp;lt;#dispatch_object_t  _Nonnull object#&amp;gt;, dispatch_queue_t  _Nullable queue)

   dispatch_queue_t globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);

   dispatch_set_target_queue(mySerialDispatchQueue, globalDispatchQueueBackground);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定要变更执行优先级的Dispatch Queue 为 dispatch_set_target_queue函数的第一个参数，指定与要使用的执行优先级相同优先级的Global Dispatch Queue为第二个参数（目标）。第一个参数如果指定系统提供的Main Dispatch Queue 和 Global Dispatch Queue 则不知道会出现什么情况。因为你不能给系统的queue设置权限，所以这些均不可指定。&lt;/p&gt;

&lt;p&gt;一般都是把一个任务放到一个串行的queue中，如果这个任务被拆分了，被放置到多个串行的queue中，但实际还是需要这个任务同步执行，那么就会有问题，因为多个串行queue之间是并行的。这时使用dispatch_set_target_queue将多个串行的queue指定到了同一目标，那么着多个串行queue在目标queue上就是同步执行的，不再是并行执行。&lt;/p&gt;

&lt;h4 id=&#34;dispatch-after&#34;&gt;dispatch_after&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW,(int64_t)(3 * NSEC_PER_SEC));
     dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(33 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSLog(@&amp;quot;waited at least three seconds&amp;quot;);
    });

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dispatch_after 函数并不是在指定时间后执行，只是在指定时间追加处理到Dispatch Queue中。&lt;/p&gt;

&lt;p&gt;第一个参数是指定时间用的dispatch_time_t 类型的值。使用dispatch_time 或者dispatch_walltimeb&lt;/p&gt;

&lt;p&gt;第二个参数指定要追加处理的Dispatch Queuede，第三个参数指定执行处理的block。&lt;/p&gt;

&lt;h4 id=&#34;dispatch-group&#34;&gt;Dispatch Group&lt;/h4&gt;

&lt;p&gt;在追加到&lt;code&gt;Dispatch Queue&lt;/code&gt;中的多个处理全部结束后执行结束处理。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将执行的处理全部追加到 一个&lt;code&gt;Serial Dispatch Queue&lt;/code&gt;中，并在最后追加结束处理。&lt;/li&gt;
&lt;li&gt;但是在并行队列中可以使用&lt;code&gt;Dispatch Group&lt;/code&gt;实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Target：追加3个&lt;code&gt;block&lt;/code&gt;到&lt;code&gt;Global Dispatch Queue&lt;/code&gt; 中，这些&lt;code&gt;Block&lt;/code&gt;如果全部执行完成，就会执行&lt;code&gt;Main Dispatch Queue&lt;/code&gt;中结束处理的&lt;code&gt;Block&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;    dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_group_async(group, queue, ^{  NSLog(@&amp;quot;blk0&amp;quot;); });
    dispatch_group_async(group, queue, ^{  NSLog(@&amp;quot;blk1&amp;quot;); });
    dispatch_group_async(group, queue, ^{  NSLog(@&amp;quot;blk2&amp;quot;); });
    dispatch_group_async(group, queue, ^{  sleep(3); NSLog(@&amp;quot;blk3&amp;quot;); });
    dispatch_group_async(group, queue, ^{  NSLog(@&amp;quot;blk4&amp;quot;); });
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        NSLog(@&amp;quot;over&amp;quot;);
    });

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;解析：&lt;/strong&gt; 向并行线程追加处理，多个线程并行执行，所以执行的顺序不定。 但是&lt;code&gt;”over”&lt;/code&gt;一定是最后执行的。另外，也可以使用&lt;code&gt;dispatch_group_wait&lt;/code&gt;函数，仅等待全部处理执行结束。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;    dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_group_async(group, queue, ^{  NSLog(@&amp;quot;blk0&amp;quot;); });
    dispatch_group_async(group, queue, ^{  NSLog(@&amp;quot;blk1&amp;quot;); });
    dispatch_group_async(group, queue, ^{  NSLog(@&amp;quot;blk2&amp;quot;); });
    dispatch_group_async(group, queue, ^{  sleep(3); NSLog(@&amp;quot;blk3&amp;quot;); });
    dispatch_group_async(group, queue, ^{  NSLog(@&amp;quot;blk4&amp;quot;); });
    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
    NSLog(@&amp;quot;over&amp;quot;);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;dispatch_group_wait&lt;/code&gt;的二个参数是等待的时间。如果返回值为0，则表示所有的任务执行完毕。否则，group中仍有任务在执行。&lt;/p&gt;

&lt;h4 id=&#34;dispatch-barrier-async&#34;&gt;dispatch_barrier_async&lt;/h4&gt;

&lt;p&gt;在访问数据库或文件时，使用&lt;code&gt;Serial Dispatch Queue&lt;/code&gt;能避免数据竞争的问题。&lt;/p&gt;

&lt;p&gt;写入处理确实不能与其他的写入处理以及包含读取处理的其他某些处理并行执行。但是如果读取处理只是与读取处理并行执行，那么多个并行执行就不会发生问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olns5z1r5.bkt.clouddn.com/image/illustration/blog_gcd_barrier.png&#34; alt=&#34;Dispatch_barrier_async函数的处理流程&#34; /&gt;&lt;/p&gt;

&lt;p&gt;首先&lt;code&gt;dispatch_queue&lt;/code&gt;生成函数&lt;code&gt;Concurrent Dispatch Queue&lt;/code&gt;,在&lt;code&gt;dispatch_async&lt;/code&gt;中追加读取操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;dispatch_queue_t = queue = dispatch_queue_create(&amp;quot;com.example.gcd.ForBarrier&amp;quot;, DISPATCH_QUEUE_CONCURRENT);
dispatch_async(queue, blk0_for_reading);
dispatch_async(queue, blk2_for_reading);
dispatch_async(queue, blk3_for_reading);
dispatch_barrier_async(queue, blk_for_writing);
dispatch_async(queue, blk4_for_reading);
dispatch_async(queue, blk5_for_reading);
dispatch_async(queue, blk6_for_reading);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dispatch-sync&#34;&gt;dispatch_sync&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;dispatch_async&lt;/code&gt;函数是&lt;code&gt;非同步&lt;/code&gt;的，即将指定的Block&lt;code&gt;非同步&lt;/code&gt;的加入到指定的&lt;code&gt;Dispatch Queue&lt;/code&gt;中，&lt;code&gt;dispatch_sync&lt;/code&gt;函数不做任何等待。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dispatch_sync&lt;/code&gt;函数&lt;code&gt;同步&lt;/code&gt;的将Block追加到&lt;code&gt;Dispatch Queue&lt;/code&gt;中，在Block结束之前，函数会一直等待。&lt;/p&gt;

&lt;p&gt;经常使用的一种情形是：执行&lt;code&gt;Main Dispatch Queue&lt;/code&gt;时，使用另外的线程&lt;code&gt;Global Dispatch Queue&lt;/code&gt;进行处理，处理结束后立即使用所得到的结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),^{
  /*
   处理
   */
   dispatch_sync(dispatch_get_main_queue(), ^{
     // 主线程操作，如刷新UI
     });
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦调用&lt;code&gt;dispatch_sync&lt;/code&gt;函数，那么在指定的处理结束之前，该函数都不会返回。也是因为这个特性，在使用不当时，便会造成一个严重的问题，即&lt;code&gt;死锁&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;例如在主线程中使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;dispatch_sync(dispatch_get_main_queue(), ^{
  NSLog(@&amp;quot;Hello????&amp;quot;);
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dispatch-apply&#34;&gt;dispatch_apply&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;dispatch_apply&lt;/code&gt;函数是&lt;code&gt;dispatch_sync&lt;/code&gt;和&lt;code&gt;Dispatch Group&lt;/code&gt;的关联API。
它按指定的次数将指定的&lt;code&gt;Block&lt;/code&gt;追加到指定的&lt;code&gt;Dispatch Queue&lt;/code&gt;,并等待全部处理执行结束。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;dispatch_queue queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply(10, queue, ^(size_t index){
  NSLog(@&amp;quot;%zu&amp;quot;,index);
  });
  NSLog(@&amp;quot;Done&amp;quot;); // 最后执行！
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dispatch-suspend-dispatch-resume&#34;&gt;dispatch_suspend/dispatch_resume&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;dispatch_suspend&lt;/code&gt;挂起指定的&lt;code&gt;Dispatch Queue&lt;/code&gt;。
‵‵‵
dispatch_suspend(queue);
‵‵‵
&lt;code&gt;dispatch_resume&lt;/code&gt;恢复指定的&lt;code&gt;Dispatch Queue&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;dispatch-once&#34;&gt;dispatch_once&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;static int initialized = NO;
if (initialized == NO) {
    /*
     * 初始化
     */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;static dispatch_once_t pred;
dispatch_once(&amp;amp;pred, ^{
   /*
    * 初始化
    */
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;code&gt;dispatch_once&lt;/code&gt; 函数，代码即使在多线程环境下执行，也可保证百分之百安全。&lt;/p&gt;

&lt;p&gt;第一组代码在大多数情况下也是安全的。但在多核CPU中，在正在更新的表示是否初始化的标志变量时，读取，就有可能多次执行初始化处理。而用&lt;code&gt;dispatch_once&lt;/code&gt;函数初始化就不必担心这样的问题。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.dreamingwish.com/article/gcd-guide-dispatch-once-1.html&#34;&gt;GCD外传：dispatch_once(上)&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Swift:Automatic Reference Counting in Swift</title>
      <link>https://mjyi.github.io/post/1612-arc-in-swift/</link>
      <pubDate>Fri, 30 Dec 2016 10:40:56 +0000</pubDate>
      
      <guid>https://mjyi.github.io/post/1612-arc-in-swift/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&#34;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID48&#34;&gt;Automatic Reference Counting&lt;/a&gt;
翻译： &lt;a href=&#34;https://www.cnswift.org/&#34;&gt;https://www.cnswift.org/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Swift&lt;/code&gt; 使用自动引用计数*(ARC)*机制来追踪和管理你的APP的内存使用。在大多数情况下，这意味着内存管理在Swift中“正常工作”，不需要自己考虑内存管理。ARC会自动释放类实例所占用的内存。&lt;/p&gt;

&lt;p&gt;但是，少数情况下，&lt;code&gt;ARC&lt;/code&gt;需要更多关于你和你代码之间的关系信息，以方便帮助你管理内存。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;
引用计数仅适用于类的实例。结构和枚举是值类型，而不是引用类型，不会通过引用存储和传递。
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;arc工作机制&#34;&gt;ARC工作机制&lt;/h2&gt;

&lt;p&gt;当我们创建一个类的实例时，&lt;code&gt;ARC&lt;/code&gt; 会分类一块内存来存储这个实例的信息。包括实例的内存信息，以及实例所有存储属性值的信息。&lt;/p&gt;

&lt;p&gt;另外，当实例不再需要时，&lt;code&gt;ARC&lt;/code&gt; 会释放实例所占用的内存。这样确保类实例当它不需要时，不会一直占着内存。&lt;/p&gt;

&lt;p&gt;但是，如果&lt;code&gt;ARC&lt;/code&gt;释放了一个正在使用的实例的内存，将无法再访问该实例的属性，或者调用该实例的方法。事实上，如果你试图访问实例，你的应用程序很可能会崩溃。&lt;/p&gt;

&lt;p&gt;为了确保实例在仍然需要时不消失，ARC跟踪有多少属性，常量和变量当前指向每个类实例。只要至少有一个对该实例的活动引用仍然存在，ARC就不会释放实例。&lt;/p&gt;

&lt;p&gt;为了实现这些，无论你将实例分配给属性，常量或变量，它们都会创建该实例的&lt;code&gt;强引用&lt;/code&gt;(strong)。之所以称之为“强”引用，是因为它会将实例保持住，只要强引用还在，实例是不允许被销毁的。&lt;/p&gt;

&lt;h2 id=&#34;arc&#34;&gt;ARC&lt;/h2&gt;

&lt;p&gt;下面的例子展示了自动引用计数的工作机制、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Person {
    let name: String
    init(name: String) {
        self.name = name
        print(&amp;quot;\(name) is being initialized&amp;quot;)
    }
    deinit {
        print(&amp;quot;\(name) is being deinitialized&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Person&lt;/code&gt; 类有一个初始化器， 它设定了实例的&lt;code&gt;name&lt;/code&gt; 属性。一个反初始化器，会在类的实例被销毁的时候打印一条信息。&lt;/p&gt;

&lt;p&gt;现在定义三个&lt;code&gt;Person?&lt;/code&gt; 类型的变量，用来按照代码的顺序，为新的&lt;code&gt;Person&lt;/code&gt; 实例设置引用。由于可选类型的变量会被自动初始化为一个&lt;code&gt;nil&lt;/code&gt;值，目前还不会引用到&lt;code&gt;Person&lt;/code&gt; 类的实例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var reference1: Person?   // nil
var reference2: Person?	  // nil
var reference3: Person?   // nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个新的 Person 实例并且将它赋值&lt;code&gt;reference1&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reference1 = Person(name: &amp;quot;John Appleseed&amp;quot;)		// Person
// print &amp;quot;John Appleseed is being initialized&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;类实例之间的循环强引用&#34;&gt;类实例之间的循环强引用&lt;/h2&gt;

&lt;p&gt;如果两个类实例彼此持有对方的强引用，因而每个实例都让对方一直存在，就会发生这种情况。这就是所谓的&lt;code&gt;循环强引用&lt;/code&gt;。(Strong reference Cycles Between Class Instances)&lt;/p&gt;

&lt;p&gt;解决循环强引用问题，可以通过定义类之间的关系为弱引用(&lt;code&gt;weak&lt;/code&gt;)或无主引用(&lt;code&gt;unowned&lt;/code&gt;)来代替强引用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print(&amp;quot;\(name) is being deinitialized&amp;quot;) }
}
 
class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    var tenant: Person?
    deinit { print(&amp;quot;Apartment \(unit) is being deinitialized&amp;quot;) }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个类都定义了反初始化器，用以在类实例被反初始化时输出信息.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var john: Person?			// nil
var unit4A: Apartment?		// nil

john = Person(name: &amp;quot;John Appleseed&amp;quot;)	// Person
unit4A = Apartment(unit: &amp;quot;4A&amp;quot;)			// Apartment

john!.apartment = unit4A
unit4A!.tenant = john

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;感叹号( ! )是用来展开和访问可选变量 john 和 unit4A 里的实例的，所以这些实例的属性可以设置。&lt;/p&gt;

&lt;p&gt;这两个实例关联后会产生一个循环强引用。 &lt;code&gt;Person&lt;/code&gt; 实例现在有了一个指向 &lt;code&gt;Apartment&lt;/code&gt; 实例的强引用，而 &lt;code&gt;Apartment&lt;/code&gt; 实例也有了一个指向 &lt;code&gt;Person&lt;/code&gt; 实例的强引用。因此，当你断开 &lt;code&gt;john&lt;/code&gt; 和 &lt;code&gt;unit4A&lt;/code&gt;变量所持有的强引用时，引用计数并不会降零，实例也不会被 ARC 释放：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;john = nil
unit4A = nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，当你把这两个变量设为 &lt;code&gt;nil&lt;/code&gt; 时，没有任何一个反初始化器被调用。循环强引用会一直阻止 &lt;code&gt;Person&lt;/code&gt; 和 &lt;code&gt;Apartment&lt;/code&gt; 类实例的释放，这就在你的应用程序中造成了内存泄漏。&lt;/p&gt;

&lt;h2 id=&#34;解决实例之间的循环强引用&#34;&gt;解决实例之间的循环强引用&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Swift&lt;/code&gt; 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（ &lt;code&gt;weak reference&lt;/code&gt; ）和无主引用（ &lt;code&gt;unowned reference&lt;/code&gt; )。&lt;/p&gt;

&lt;h4 id=&#34;弱引用-weak&#34;&gt;弱引用 weak&lt;/h4&gt;

&lt;p&gt;弱引用不会对其引用的实例保持强引用，因而不会阻止&lt;code&gt;ARC&lt;/code&gt; 释放被引用的实例。这个特性阻止了引用变为循环强引用。声明属性或者变量时，在前面加上&lt;code&gt;weak&lt;/code&gt;关键字表明这是一个弱引用。&lt;/p&gt;

&lt;p&gt;由于弱引用不会强保持对实例的引用，所以说实例被释放了弱引用仍旧引用着这个实例也是有可能的。因此，&lt;code&gt;ARC&lt;/code&gt; 会在被引用的实例被释放是自动地设置弱引用为 &lt;code&gt;nil&lt;/code&gt; 。由于弱引用需要允许它们的值为 &lt;code&gt;nil&lt;/code&gt; ，它们一定得是可选类型。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;
在&lt;code&gt;ARC&lt;/code&gt;给弱引用设置&lt;code&gt;nil&lt;/code&gt;时不会调用属性观察者。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面的例子跟上面 &lt;code&gt;Person&lt;/code&gt; 和 &lt;code&gt;Apartment&lt;/code&gt; 的例子一致，但是有一个重要的区别。这次，&lt;code&gt;Apartment&lt;/code&gt; 的 &lt;code&gt;tenant&lt;/code&gt; 属性被声明为弱引用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Person {
    let name: String
    init(name: String) {
        self.name = name
        print(&amp;quot;\(name) is being initialized&amp;quot;)
    }
    var apartment: Apartment?
    deinit {
        print(&amp;quot;\(name) is being deinitialized&amp;quot;)
    }
}

class Apartment {
    let unit: String
    init(unit: String) {
        self.unit = unit
    }
    weak var tenant: Person?
    deinit {
        print(&amp;quot;Apartment \(unit) is being deinitialized&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将两个变量关联起来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var john: Person?
var unit4A: Apartment?
 
john = Person(name: &amp;quot;John Appleseed&amp;quot;)
unit4A = Apartment(unit: &amp;quot;4A&amp;quot;)
 
john!.apartment = unit4A
unit4A!.tenant = john
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Person&lt;/code&gt;实例保持对&lt;code&gt;Apartment&lt;/code&gt;实例的强引用，但是&lt;code&gt;Apartment&lt;/code&gt;实例现在对&lt;code&gt;Person&lt;/code&gt;实例是弱引用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit4A = nil
// 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时，&lt;code&gt;Person&lt;/code&gt;实例保持对&lt;code&gt;Apartment&lt;/code&gt;实例的强引用，所以 &lt;code&gt;Apartment&lt;/code&gt;实例 并没有被释放掉。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;john = nil

//	John Appleseed is being deinitialized
//	Apartment 4A is being deinitialized
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;john&lt;/code&gt;设置nil 后，没有对&lt;code&gt;Apartment&lt;/code&gt;实例的引用，所以 &lt;code&gt;Apartment&lt;/code&gt; 实例也被释放掉了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;
在使用垃圾回收机制的系统中，由于没有强引用的对象会在内存有压力时触发垃圾回收而被释放，弱指针有时用来实现简单的缓存机制。总之，对于 ARC 来说，一旦最后的强引用被移除，值就会被释放，这样的话弱引用就不再适合这类用法了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;无主引用&#34;&gt;无主引用&lt;/h4&gt;

&lt;p&gt;和&lt;code&gt;弱引用&lt;/code&gt;类似，&lt;code&gt;无主引用&lt;/code&gt;不会牢牢保持住引用的实例。但是不像&lt;code&gt;弱引用&lt;/code&gt;，总之，&lt;code&gt;无主引用&lt;/code&gt;假定是永远有值的。因此，&lt;code&gt;无主引用&lt;/code&gt;总是被定义为*非可选类型*。你可以在声明属性或者变量时，在前面加上关键字 &lt;code&gt;unowned&lt;/code&gt; 表示这是一个&lt;code&gt;无主引用&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;由于无主引用是&lt;code&gt;非可选类型&lt;/code&gt;，你不需要在使用它的时候将它展开。无主引用总是可以直接访问。不过 &lt;code&gt;ARC&lt;/code&gt; 无法在实例被释放后将无主引用设为 &lt;code&gt;nil&lt;/code&gt; ，因为非可选类型的变量不允许被赋值为 &lt;code&gt;nil&lt;/code&gt; 。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;
如果你试图在实例的被释放后访问无主引用，那么你将触发运行时错误。只有在你确保引用会一直引用实例的时候才使用无主引用。
还要注意的是，如果你试图访问引用的实例已经被释放了的无主引用，Swift 会确保程序直接崩溃。你不会因此而遭遇无法预期的行为。所以你应当避免这样的事情发生。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面看一个例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit {
        print(&amp;quot;\(name) is being deinitialized&amp;quot;)
    }
}

class CreditCard {
    let number: UInt64
    unowned let customer: Customer
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    deinit {
        print(&amp;quot;Card # \(number) is being deinitialized&amp;quot;)
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Customer&lt;/code&gt;和&lt;code&gt;CreditCard&lt;/code&gt; 类，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系可能会造成循环强引用。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Customer&lt;/code&gt; 和 &lt;code&gt;CreditCard&lt;/code&gt; 之间的关系与前面弱引用例子中 &lt;code&gt;Apartment&lt;/code&gt; 和 &lt;code&gt;Person&lt;/code&gt; 的关系略微不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系， &lt;code&gt;Customer&lt;/code&gt; 类有一个可选类型的 &lt;code&gt;card&lt;/code&gt; 属性，但是 &lt;code&gt;CreditCard&lt;/code&gt; 类有一个非可选类型的 customer 属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var john: Customer?    //nil

john = Customer(name: &amp;quot;John Appleseed&amp;quot;)
john!.card = CreditCard(number: 1234_5678_9012_3456， customer: john!)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个 &lt;code&gt;Customer&lt;/code&gt; 实例，用它初始化和分配一个新的 &lt;code&gt;CreditCard&lt;/code&gt;实例作为 &lt;code&gt;customer&lt;/code&gt; 的 &lt;code&gt;card&lt;/code&gt; 属性.&lt;/p&gt;

&lt;p&gt;现在 &lt;code&gt;Customer&lt;/code&gt; 实例对 &lt;code&gt;CreditCard&lt;/code&gt; 实例有一个强引用，并且 &lt;code&gt;CreditCard&lt;/code&gt; 实例对 &lt;code&gt;Customer&lt;/code&gt; 实例有一个无主引用。&lt;/p&gt;

&lt;p&gt;由于 &lt;code&gt;Customer&lt;/code&gt; 的无主引用，当你断开 &lt;code&gt;john&lt;/code&gt; 变量持有的强引用时，那么就再也没有指向 &lt;code&gt;Customer&lt;/code&gt; 实例的强引用了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;john = nil
// prints &amp;quot;John Appleseed is being deinitialized&amp;quot;
// prints &amp;quot;Card #1234567890123456 is being deinitialized&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;
上边的例子展示了如何使用安全无主引用。Swift 还为你需要关闭运行时安全检查的情况提供了不安全无主引用——举例来说，性能优化的时候。对于所有的不安全操作，你要自己负责检查代码安全性。
使用 &lt;code&gt;unowned(unsafe)&lt;/code&gt; 来明确使用了一个不安全无主引用。如果你在实例的引用被释放后访问这个不安全无主引用，你的程序就会尝试访问这个实例曾今存在过的内存地址，这就是不安全操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;无主引用和隐式展开的可选属性&#34;&gt;无主引用和隐式展开的可选属性&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Person&lt;/code&gt;和 &lt;code&gt;Apartment&lt;/code&gt; 的例子展示了两个属性值都允许为&lt;code&gt;nil&lt;/code&gt;，并会潜在产生循环强引用。这种场景最适合用弱引用来解决。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Customer&lt;/code&gt;和 &lt;code&gt;CreditCard&lt;/code&gt;的例子战士胃一个属性值允许为&lt;code&gt;nil&lt;/code&gt;，另一个不允许为&lt;code&gt;nil&lt;/code&gt;，这也有可能导致循环强引用。这种场景最好使用&lt;code&gt;无主引用&lt;/code&gt;来解决。&lt;/p&gt;

&lt;p&gt;还有第三中场景，两个属性都必须有值，并且初始化完成后永远不会为&lt;code&gt;nil&lt;/code&gt;。在这种场景中，需要一个类使用&lt;code&gt;无主属性&lt;/code&gt;，而另一个类使用隐式展开的&lt;code&gt;可选属性&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;下面的例子定义了两个类，&lt;code&gt;Country&lt;/code&gt;和&lt;code&gt;City&lt;/code&gt;，每个类将另外一个类的实例保存为属性。在这个数据模型中，每个国家必须有首都，每个城市必须属于一个国家。为了实现这种关系， &lt;code&gt;Country&lt;/code&gt; 类拥有一个 &lt;code&gt;capitalCity&lt;/code&gt; 属性，而 &lt;code&gt;City&lt;/code&gt; 类有一个 &lt;code&gt;country&lt;/code&gt; 属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Country {
    let name: String
    var capitalCity: City!
    init(name: String, capitalName: String) {
        self.name = name
        self.capitalCity = City(name: capitalName, country: self)
    }
}


class City {
    let name: String
    unowned let country: Country
    init(name: String, country: Country) {
        self.name = name
        self.country = country
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了建立两个类的依赖关系，&lt;code&gt;City&lt;/code&gt;的初始化器 接收一个&lt;code&gt;Country&lt;/code&gt;实例，并且将实例保存 到 &lt;code&gt;country&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Country&lt;/code&gt;的初始化器调用了&lt;code&gt;City&lt;/code&gt;的初始化器。总之，如同在两段式初始化中描述的那样，只有&lt;code&gt;Country&lt;/code&gt;的实例完全初始化完成后，&lt;code&gt;Country&lt;/code&gt;的初始化器才能把&lt;code&gt;self&lt;/code&gt;传给&lt;code&gt;City&lt;/code&gt;的初始化器。&lt;/p&gt;

&lt;p&gt;为了满足这种需求，通过在类型结尾处加上感叹号（&lt;code&gt;City!&lt;/code&gt; ）的方式，以声明 &lt;code&gt;Country&lt;/code&gt; 的 &lt;code&gt;capitalCity&lt;/code&gt; 属性为一个隐式展开的可选属性。如同在隐式展开可选项中描述的那样，这意味着像其他可选项一样， &lt;code&gt;capitalCity&lt;/code&gt; 属性有一个默认值 &lt;code&gt;nil&lt;/code&gt; ，但是不需要展开它的值就能访问它。&lt;/p&gt;

&lt;p&gt;由于 &lt;code&gt;capitalCity&lt;/code&gt; 默认值为 &lt;code&gt;nil&lt;/code&gt; ，一旦 &lt;code&gt;Country&lt;/code&gt; 的实例在初始化器中给 &lt;code&gt;name&lt;/code&gt; 属性赋值后，整个初始化过程就完成了。这意味着一旦 &lt;code&gt;name&lt;/code&gt; 属性被赋值后， &lt;code&gt;Country&lt;/code&gt; 的初始化器就能引用并传递隐式的 &lt;code&gt;self&lt;/code&gt; 。 &lt;code&gt;Country&lt;/code&gt; 的初始化器在赋值 &lt;code&gt;capitalCity&lt;/code&gt; 时，就能将 &lt;code&gt;self&lt;/code&gt; 作为参数传递给 &lt;code&gt;City&lt;/code&gt; 的初始化器。&lt;/p&gt;

&lt;p&gt;以上的意义在于你可以通过一条语句同时创建&lt;code&gt;Country&lt;/code&gt;和&lt;code&gt;City&lt;/code&gt;的实例，而不产生循环引用。并且 &lt;code&gt;capitalCity&lt;/code&gt; 的属性能被直接访问，而不需要通过感叹号来展开它的可选值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var country = Country(name: &amp;quot;Canada&amp;quot;, capitalName: &amp;quot;Ottawa&amp;quot;)
print(&amp;quot;\(country.name)&#39;s capital city is called \(country.capitalCity.name)&amp;quot;)
// prints &amp;quot;Canada&#39;s capital city is called Ottawa&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;闭包的循环强引用&#34;&gt;闭包的循环强引用&lt;/h2&gt;

&lt;p&gt;循环强引用还会出现在你把一个闭包分配给类实例属性的时候，并且这个闭包中又捕获了这个实例。
捕获可能发生于这个闭包函数体中访问了实例的某个属性，比如&lt;code&gt;self.someProperty&lt;/code&gt;，或者这个闭包调用了一个实例的方法，例如&lt;code&gt;self.someMethod()&lt;/code&gt;. 这两种情况都导致了闭包“捕获”了&lt;code&gt;self&lt;/code&gt;，从而产生了循环强引用。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;循环强引用&lt;/code&gt;的产生，是因为闭包和类相似，都是&lt;code&gt;引用类型&lt;/code&gt;。当你把闭包赋值给了一个属性，你实际上是把一个引用赋值给了这个闭包。实质上，这跟之前上面的问题是一样的——两个强引用让彼此一直有效。总之，和两个类实例不同，这次一个是类实例和一个闭包互相引用。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Swift&lt;/code&gt; 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表（ &lt;code&gt;closuer capture list&lt;/code&gt;）。不过，在学习如何用闭包捕获列表打破循环强引用之前，我们还是先来了解一下这个循环强引用是如何产生的，这对我们很有帮助。&lt;/p&gt;

&lt;p&gt;下面的例子为你展示了当一个闭包引用了&lt;code&gt;self&lt;/code&gt;后是如何产生一个循环强引用的。例子中定义了一个叫 &lt;code&gt;HTMLElement&lt;/code&gt; 的类，用一种简单的模型表示 &lt;code&gt;HTML&lt;/code&gt; 中的一个单独的元素：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class HTMLElement {
    let name: String
    let text: String?
    lazy var asHTML: (Void) -&amp;gt; String = {
        if let text = self.text {
            return &amp;quot;&amp;lt;\(self.name)&amp;gt;\(text)&amp;lt;/\(self.name)&amp;gt;&amp;quot;
        } else {
            return &amp;quot;&amp;lt;\(self.name) /&amp;gt;&amp;quot;
        }
    }
    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }
    
    deinit {
        print(&amp;quot;\(name) is being deinitialized&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下，闭包赋值给了 &lt;code&gt;asHTML&lt;/code&gt; 属性，这个闭包返回一个代表&lt;code&gt;HTML&lt;/code&gt;标签的字符串。如果 &lt;code&gt;text&lt;/code&gt; 值存在，该标签就包含可选值 &lt;code&gt;text&lt;/code&gt; ；如果 &lt;code&gt;text&lt;/code&gt; 不存在，该标签就不包含文本。对于段落元素，根据 &lt;code&gt;text&lt;/code&gt; 是 &amp;ldquo;some text&amp;rdquo; 还是 &lt;code&gt;nil&lt;/code&gt; ，闭包会返回 &lt;code&gt;&amp;lt;p&amp;gt;some text&amp;lt;/p&amp;gt;&lt;/code&gt; 或者 &lt;code&gt;&amp;lt;p /&amp;gt;&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;可以像实例方法那样去命名、使用 &lt;code&gt;asHTML&lt;/code&gt; 属性。总之，由于 &lt;code&gt;asHTML&lt;/code&gt; 是闭包而不是实例方法，如果你想改变特定元素的 &lt;code&gt;HTML&lt;/code&gt;处理的话，可以用自定义的闭包来取代默认值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let heading = HTMLElement(name: &amp;quot;h1&amp;quot;)
let defaultText = &amp;quot;some default text&amp;quot;
heading.asHTML = {
    return &amp;quot;&amp;lt;\(heading.name)&amp;gt;\(heading.text ?? defaultText)&amp;lt;/\(heading.name)&amp;gt;&amp;quot;
}

print(heading.asHTML())
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;
&lt;code&gt;asHTML&lt;/code&gt; 声明为&lt;code&gt;lazy&lt;/code&gt;属性，因为只有当元素确实需要处理为&lt;code&gt;HTML&lt;/code&gt;输出的字符串时，才需要使用 &lt;code&gt;asHTML&lt;/code&gt;。
实际上 asHTML 是延迟加载属性意味着你在默认的闭包中可以使用 &lt;code&gt;self&lt;/code&gt; ，因为只有当初始化完成以及 self 确实存在后，才能访问延迟加载属性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;HTMLElement&lt;/code&gt; 类只提供一个初始化器，通过 name 和 text （如果有的话）参数来初始化一个元素。该类也定义了一个初始化器，当 &lt;code&gt;HTMLElement&lt;/code&gt; 实例被释放时打印一条消息。&lt;/p&gt;

&lt;p&gt;实例的 &lt;code&gt;asHTML&lt;/code&gt; 属性持有闭包的强引用。但是，闭包在其闭包体内使用了 &lt;code&gt;self&lt;/code&gt;（引用了 &lt;code&gt;self.name&lt;/code&gt; 和 &lt;code&gt;self.text&lt;/code&gt; ），因此闭包捕获了 &lt;code&gt;self&lt;/code&gt; ，这意味着闭包又反过来持有了 &lt;code&gt;HTMLElement&lt;/code&gt; 实例的强引用。这样两个对象就产生了循环强引用。（更多关于闭包捕获值的信息，请参考值捕获）。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;
尽管闭包多次引用&lt;code&gt;HTMLElement&lt;/code&gt;,它只捕获&lt;code&gt;HTMLElement&lt;/code&gt;实例的一个强引用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果设置 paragraph 变量为 nil ，打破它持有的 HTMLElement 实例的强引用， HTMLElement 实例和它的闭包都不会被释放，也是因为循环强引用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;paragraph = nil
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;解决闭包的循环强引用&#34;&gt;解决闭包的循环强引用&lt;/h2&gt;

&lt;p&gt;你可以通过定义捕获列表作为闭包的定义来解决在闭包和类实例之间的循环强引用。捕获列表定义了当在闭包体里捕获一个或多个引用类型的规则。正如在两个类实例之间的循环强引用，声明每个捕获的引用为引用或无主引用而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;
&lt;code&gt;Swift&lt;/code&gt; 要求你在闭包中引用&lt;code&gt;self&lt;/code&gt;成员时使用 &lt;code&gt;self.someProperty&lt;/code&gt; 或者&lt;code&gt;self.someMethod&lt;/code&gt; （而不只是 &lt;code&gt;someProperty&lt;/code&gt; 或 &lt;code&gt;someMethod&lt;/code&gt; ）。这有助于提醒你可能会一不小心就捕获了 &lt;code&gt;self&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;lazy var someClosure: (Int, String) -&amp;gt; String = {
    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&amp;gt; String in
    // closure body goes here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果闭包没有指明形式参数列表或者返回类型，是因为它们会通过上下文推断，那么就把捕获列表放在关键字 in 前边，闭包最开始的地方：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lazy var someClosure: Void -&amp;gt; String = {
    [unowned self, weak delegate = self.delegate!] in
    // closure body goes here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;弱引用和无主引用&#34;&gt;弱引用和无主引用&lt;/h2&gt;

&lt;p&gt;在闭包和捕获的实例总是互相引用并且总是同时释放时，将闭包内的捕获定义为无主引用。&lt;/p&gt;

&lt;p&gt;相反，在被捕获的引用可能会变为 nil 时，定义一个弱引用的捕获。弱引用总是可选项，当实例的引用释放时会自动变为 nil 。这使我们可以在闭包体内检查它们是否存在。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;
如果被捕获的引用永远不会变为&lt;code&gt;nil&lt;/code&gt; ，应该用无主引用而不是弱引用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前面的 &lt;code&gt;HTMLElement&lt;/code&gt;例子中，无主引用是正确的解决循环强引用的方法。这样编写 &lt;code&gt;HTMLElement&lt;/code&gt; 类来避免循环强引用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class HTMLElement {
    
    let name: String
    let text: String?
    
    lazy var asHTML: Void -&amp;gt; String = {
        [unowned self] in
        if let text = self.text {
            return &amp;quot;&amp;lt;\(self.name)&amp;gt;\(text)&amp;lt;/\(self.name)&amp;gt;&amp;quot;
        } else {
            return &amp;quot;&amp;lt;\(self.name) /&amp;gt;&amp;quot;
        }
    }
    
    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }
    
    deinit {
        print(&amp;quot;\(name) is being deinitialized&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的 &lt;code&gt;HTMLElement&lt;/code&gt; 实现和之前的实现一致，除了在&lt;code&gt;asHTML&lt;/code&gt; 闭包中多了一个捕获列表。这里，捕获列表是 &lt;code&gt;[unowned self]&lt;/code&gt; ，表示“用无主引用而不是强引用来捕获 &lt;code&gt;self&lt;/code&gt; 。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var paragraph: HTMLElement? = HTMLElement(name: &amp;quot;p&amp;quot;, text: &amp;quot;hello, world&amp;quot;)
print(paragraph!.asHTML())
// prints &amp;quot;&amp;lt;p&amp;gt;hello, world&amp;lt;/p&amp;gt;&amp;quot;

paragraph = nil
// prints &amp;quot;p is being deinitialized&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;end!!!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS:关于iOS的推送</title>
      <link>https://mjyi.github.io/post/1612-remotenotification/</link>
      <pubDate>Fri, 23 Dec 2016 16:38:19 +0000</pubDate>
      
      <guid>https://mjyi.github.io/post/1612-remotenotification/</guid>
      <description>&lt;p&gt;苹果的在iOS 10 中将通知相关的API统一成了&lt;code&gt;UserNotifications.framework&lt;/code&gt;。在新的&lt;code&gt;UserNotifications.framework&lt;/code&gt;中，苹果还增加了撤回单条通知，更新已展示同比，中途修改通知内容，在通知中展示图片、视频，自定义通知UI等一系列新功能。&lt;/p&gt;

&lt;h3 id=&#34;ios-10中使用远程推送&#34;&gt;iOS 10中使用远程推送&lt;/h3&gt;

&lt;p&gt;在&lt;code&gt;Project&lt;/code&gt; -&amp;gt; &lt;code&gt;Project Setting&lt;/code&gt; - &amp;gt; &lt;code&gt;Capabilities&lt;/code&gt;, 打开 &lt;code&gt;Push Notifications&lt;/code&gt; 开关。&lt;/p&gt;

&lt;h3 id=&#34;注册通知&#34;&gt;注册通知&lt;/h3&gt;

&lt;p&gt;注册通知在&lt;code&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(nullable NSDictionary *)launchOptions NS_AVAILABLE_IOS(3_0);&lt;/code&gt; 方法里。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;iOS 10&lt;/code&gt;使用&lt;code&gt;- (void)requestAuthorizationWithOptions:(UNAuthorizationOptions)options completionHandler:(void (^)(BOOL granted, NSError *__nullable error))completionHandler;&lt;/code&gt; 方法来注册通知。

导入 &lt;code&gt;#import &amp;lt;UserNotifications/UserNotifications.h&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;        // 使用 UNUserNotificationCenter 来管理通知
        UNUserNotificationCenter *uncenter = [UNUserNotificationCenter currentNotificationCenter];
        // 监听回调事件
        [uncenter setDelegate:self];
        [uncenter requestAuthorizationWithOptions:(UNAuthorizationOptionAlert+UNAuthorizationOptionBadge+UNAuthorizationOptionSound)
                                completionHandler:^(BOOL granted, NSError * _Nullable error) {
                                    [[UIApplication sharedApplication] registerForRemoteNotifications];
                                    NSLog(@&amp;quot;%@&amp;quot; , granted ? @&amp;quot;授权成功&amp;quot; : @&amp;quot;授权失败&amp;quot;);
                                }];
        // 获取当前的通知授权状态, UNNotificationSettings
        [uncenter getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) {
            NSLog(@&amp;quot;%s\nline:%@\n-----\n%@\n\n&amp;quot;, __func__, @(__LINE__), settings);
            if (settings.authorizationStatus == UNAuthorizationStatusNotDetermined) {
                NSLog(@&amp;quot;未选择&amp;quot;);
            } else if (settings.authorizationStatus == UNAuthorizationStatusDenied) {
                NSLog(@&amp;quot;未授权&amp;quot;);
            } else if (settings.authorizationStatus == UNAuthorizationStatusAuthorized) {
                NSLog(@&amp;quot;已授权&amp;quot;);
            }
        }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的方法只在&lt;code&gt;ios 10&lt;/code&gt;中有效， 所以要想兼容之前的版本，还是需要适配&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;- (void)registerForRemoteNotification {
    // iOS10 兼容
    if ([[UIDevice currentDevice].systemVersion floatValue] &amp;gt;= 10.0) {
        // 使用 UNUserNotificationCenter 来管理通知
        UNUserNotificationCenter *uncenter = [UNUserNotificationCenter currentNotificationCenter];
        // 监听回调事件
        [uncenter setDelegate:self];
        [uncenter requestAuthorizationWithOptions:(UNAuthorizationOptionAlert+UNAuthorizationOptionBadge+UNAuthorizationOptionSound)
                                completionHandler:^(BOOL granted, NSError * _Nullable error) {
                                    [[UIApplication sharedApplication] registerForRemoteNotifications];
                                    NSLog(@&amp;quot;%@&amp;quot; , granted ? @&amp;quot;授权成功&amp;quot; : @&amp;quot;授权失败&amp;quot;);
                                }];
        // 获取当前的通知授权状态, UNNotificationSettings
        [uncenter getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) {
            NSLog(@&amp;quot;%s\nline:%@\n-----\n%@\n\n&amp;quot;, __func__, @(__LINE__), settings);
            if (settings.authorizationStatus == UNAuthorizationStatusNotDetermined) {
                NSLog(@&amp;quot;未选择&amp;quot;);
            } else if (settings.authorizationStatus == UNAuthorizationStatusDenied) {
                NSLog(@&amp;quot;未授权&amp;quot;);
            } else if (settings.authorizationStatus == UNAuthorizationStatusAuthorized) {
                NSLog(@&amp;quot;已授权&amp;quot;);
            }
        }];
    }
#pragma clang diagnostic push
#pragma clang diagnostic ignored &amp;quot;-Wdeprecated-declarations&amp;quot;
    if ([[UIDevice currentDevice].systemVersion floatValue] &amp;gt;= 8.0) {
        UIUserNotificationType types = UIUserNotificationTypeAlert |
        UIUserNotificationTypeBadge |
        UIUserNotificationTypeSound;
        UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:types categories:nil];
        
        [[UIApplication sharedApplication] registerUserNotificationSettings:settings];
        [[UIApplication sharedApplication] registerForRemoteNotifications];
    } else {
        UIRemoteNotificationType types = UIRemoteNotificationTypeBadge |
        UIRemoteNotificationTypeAlert |
        UIRemoteNotificationTypeSound;
        [[UIApplication sharedApplication] registerForRemoteNotificationTypes:types];
    }
#pragma clang diagnostic pop
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注册结果的回调还是&lt;code&gt;AppDelegate&lt;/code&gt;的代理方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;- (void)application:(UIApplication *)app didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {
    NSString *token = [NSString stringWithFormat:@&amp;quot;%@&amp;quot;, deviceToken];
    NSString *dt = [token stringByTrimmingCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@&amp;quot;&amp;lt;&amp;gt;&amp;quot;]];
    NSString *dn = [dt stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    TheRuntime.pushToken = [dn stringByReplacingOccurrencesOfString:@&amp;quot; &amp;quot; withString:@&amp;quot;&amp;quot;];
    DDLog(@&amp;quot;deviceToken____: %@&amp;quot;,TheRuntime.pushToken);
}

//查看推送功能是否失败
- (void)application:(UIApplication *)app didFailToRegisterForRemoteNotificationsWithError:(NSError *)error {
    NSString *error_str = [NSString stringWithFormat: @&amp;quot;%@&amp;quot;, error];
    DDLog(@&amp;quot;Token Error: %@&amp;quot;,error_str);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;响应通知&#34;&gt;响应通知&lt;/h3&gt;

&lt;h4 id=&#34;ios-10-之前版本&#34;&gt;iOS 10 之前版本&lt;/h4&gt;

&lt;p&gt;在&lt;code&gt;iOS 10&lt;/code&gt;之前的版本中，当应用是被通知打开的时候,可以通过 &lt;code&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt;方法的&lt;code&gt;launchOptions&lt;/code&gt; 参数所使用的 &lt;code&gt;dictionary&lt;/code&gt;访问到数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    . . .
    if ([[UIDevice currentDevice].systemVersion floatValue] &amp;lt; 10.0) {
        NSDictionary *notificationPayload = launchOptions[UIApplicationLaunchOptionsRemoteNotificationKey];
		if (notificationPayload) {
			NSLog(@&amp;quot;%@&amp;quot;,notificationPayload);
		} 
    }
    return YES;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果当通知到达的时候，你的应用已经在运行，通过 &lt;code&gt;application:didReceiveRemoteNotification:fetchCompletionHandler:&lt;/code&gt; 方法的 &lt;code&gt;userInfo&lt;/code&gt; 参数所使用 &lt;code&gt;dictionary&lt;/code&gt;访问到数据:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt; //  Required for iOS 7+
- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler {
    //处理远程推送内容
    NSLog(@&amp;quot;iOS7及以上系统，收到通知:%@&amp;quot;, userInfo);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;iOS10 以上需要使用下面代理方法来获得 &lt;code&gt;userInfo&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;//  在前台收到推送内容, 执行的方法
- (void)userNotificationCenter:(UNUserNotificationCenter *)center
       willPresentNotification:(UNNotification *)notification
         withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler {
    NSDictionary *userInfo = notification.request.content.userInfo;
    if([notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) {
        //TODO:处理远程推送内容
        NSLog(@&amp;quot;%@&amp;quot;, userInfo);
    }
    // 需要执行这个方法，选择是否提醒用户，有 Badge、Sound、Alert 三种类型可以选择设置
    completionHandler(UNNotificationPresentationOptionAlert);
}

// 在后台和启动之前收到推送内容, 点击推送内容后，执行的方法
- (void)userNotificationCenter:(UNUserNotificationCenter *)center
didReceiveNotificationResponse:(UNNotificationResponse *)response
         withCompletionHandler:(void (^)())completionHandler {
    NSDictionary * userInfo = response.notification.request.content.userInfo;
    if([response.notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) {
        //TODO:处理远程推送内容
        NSLog(@&amp;quot;%@&amp;quot;, userInfo);
    }
    completionHandler();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后附上2篇参考文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://onevcat.com/2016/08/notification/&#34;&gt;活久见的重构 - iOS 10 UserNotifications 框架解析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;ttps://www.sitepoint.com/developing-push-notifications-for-ios-10/&#34;&gt;Developing Push Notifications for iOS 10&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Hexo常用的内置标签记录</title>
      <link>https://mjyi.github.io/post/1612-hexo-tag/</link>
      <pubDate>Thu, 15 Dec 2016 15:58:42 +0000</pubDate>
      
      <guid>https://mjyi.github.io/post/1612-hexo-tag/</guid>
      <description>&lt;h2 id=&#34;hexo-标签&#34;&gt;Hexo 标签&lt;/h2&gt;

&lt;p&gt;「标签」(Tag Plugin) 是 Hexo 提供的一种快速生成特定内容的方式。 在标准 Markdown 中，我们无法指定图片的大小，在这种情景下，我们即可使用标签来解决。 Hexo 内置来许多标签来帮助写作者可以更快的书写， &lt;a href=&#34;https://hexo.io/docs/tag-plugins.html&#34;&gt;完整的标签列表&lt;/a&gt; 可以参考 Hexo 官网。&lt;/p&gt;

&lt;h3 id=&#34;文本居中的引用&#34;&gt;文本居中的引用&lt;/h3&gt;

&lt;p&gt;此标签将生成一个带上下分割线的引用，同时引用内文本将自动居中。 文本居中时，多行文本若长度不等，视觉上会显得不对称，因此建议在引用单行文本的场景下使用。 例如作为文章开篇引用 或者 结束语之前的总结引用。
&lt;/p&gt;

&lt;h4 id=&#34;使用方式&#34;&gt;使用方式&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;HTML方式：使用这种方式时，给 img 添加属性 class=&amp;ldquo;blockquote-center&amp;rdquo; 即可。&lt;/li&gt;
&lt;li&gt;标签方式：使用 centerquote 或者 简写 cq。
此标签要求 NexT 的版本在 0.4.5 或以上。 若你正在使用的版本比较低，可以选择使用 HTML 方式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;标调用方法签&#34;&gt;标调用方法签&lt;/h4&gt;

&lt;p&gt;** HTML方式 **
&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;
&lt;!-- 其中 class=&#34;blockquote-center&#34; 是必须的 --&gt;
  &lt;blockquote class=&#34;blockquote-center&#34;&gt;
    如若你非我不嫁&lt;/br&gt;
    彼此终必火化&lt;/br&gt;
    一生一世等一天需要代价
  &lt;/blockquote&gt;&lt;/p&gt;

&lt;p&gt;** 标签方式 **&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% blockquote [author[, source]] [link] [source_link_title] %}
content
{% endblockquote %}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;examples-1-no-arguments-plain-blockquote&#34;&gt;Examples 1: No arguments. Plain blockquote&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;{% blockquote %}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.
{% endblockquote %}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;{% blockquote %}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.
{% endblockquote %}&lt;/p&gt;

&lt;h5 id=&#34;examples-2-quote-from-a-book&#34;&gt;Examples 2 :Quote from a book&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;{% blockquote David Levithan, Wide Awake %}
Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.
{% endblockquote %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;{% blockquote David Levithan, Wide Awake %}
Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.
{% endblockquote %}&lt;/p&gt;

&lt;h5 id=&#34;examples-3-quote-from-web&#34;&gt;Examples 3:Quote from Web&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;{% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %}
NEW: DevDocs now comes with syntax highlighting. http://devdocs.io
{% endblockquote %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;{% blockquote @DevDocs &lt;a href=&#34;https://twitter.com/devdocs/status/356095192085962752&#34;&gt;https://twitter.com/devdocs/status/356095192085962752&lt;/a&gt; %}
NEW: DevDocs now comes with syntax highlighting. &lt;a href=&#34;http://devdocs.io&#34;&gt;http://devdocs.io&lt;/a&gt;
{% endblockquote %}&lt;/p&gt;

&lt;h2 id=&#34;markdown-语法&#34;&gt;Markdown 语法&lt;/h2&gt;

&lt;h3 id=&#34;插入表格&#34;&gt;插入表格&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;一个普通标题&lt;/th&gt;
&lt;th&gt;一个普通标题&lt;/th&gt;
&lt;th&gt;一个普通标题&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;短文本&lt;/td&gt;
&lt;td&gt;中等文本&lt;/td&gt;
&lt;td&gt;稍微长一点的文本&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;稍微长一点的文本&lt;/td&gt;
&lt;td&gt;短文本&lt;/td&gt;
&lt;td&gt;中等文本&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;左对齐标题&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;右对齐标题&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;居中对齐标题&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;短文本&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;中等文本&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;稍微长一点的文本&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;稍微长一点的文本&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;短文本&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;中等文本&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
    
    <item>
      <title>使用hexo写作</title>
      <link>https://mjyi.github.io/post/1612-hexo/</link>
      <pubDate>Fri, 02 Dec 2016 16:23:11 +0000</pubDate>
      
      <guid>https://mjyi.github.io/post/1612-hexo/</guid>
      <description>&lt;h3 id=&#34;新建文章&#34;&gt;新建文章&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ hexo new [layout] &amp;lt;title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;布局-layout&#34;&gt;布局（Layout）&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://hexo.io/zh-cn/&#34;&gt;Hexo&lt;/a&gt; 的三种默认布局：&lt;code&gt;post&lt;/code&gt;、&lt;code&gt;page&lt;/code&gt;、&lt;code&gt;draft&lt;/code&gt;, 可以通过 &lt;code&gt;_config.yml&lt;/code&gt;中的&lt;code&gt;default_layout&lt;/code&gt; 来指定默认布局。它们分别对应不同的路径，如果自定义了布局，将与&lt;code&gt;post&lt;/code&gt;相同， 存储在 &lt;code&gt;source/_posts&lt;/code&gt; 文件夹。
&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;布局&lt;/th&gt;
&lt;th&gt;路径&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;post&lt;/td&gt;
&lt;td&gt;source/_posts&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;page&lt;/td&gt;
&lt;td&gt;source&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;draft&lt;/td&gt;
&lt;td&gt;source/_drafts&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;添加分类目录&#34;&gt;添加分类目录&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;hexo new page &amp;quot;categories&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时会在&lt;code&gt;source&lt;/code&gt;下生成目录&lt;code&gt;categories&lt;/code&gt;，里面有个&lt;code&gt;index.md&lt;/code&gt;文件&lt;/p&gt;

&lt;p&gt;编辑index.md，设置&lt;code&gt;type&lt;/code&gt; 值为 &lt;code&gt;categories&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;title: categories
date: 2016-12-09 15:59:21
type: &amp;quot;categories&amp;quot;
comments: false

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样页面就会显示所有的分类了。&lt;/p&gt;

&lt;h3 id=&#34;添加-tags-页面&#34;&gt;添加 tags 页面&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;tags&lt;/code&gt;同&lt;code&gt;categories&lt;/code&gt; 设置, 将&lt;code&gt;type&lt;/code&gt; 改为&lt;code&gt;tags&lt;/code&gt;即可。&lt;/p&gt;

&lt;h3 id=&#34;草稿&#34;&gt;草稿&lt;/h3&gt;

&lt;p&gt;新建的文章默认使用 post 布局，如果不想立即发布文章可以先存草稿，这时候文件将会被保存在 &lt;code&gt;source/_drafts&lt;/code&gt;中，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hexo new draft &amp;quot;paper&amp;quot;  	 
hexo publish post &amp;quot;paper&amp;quot;   //文章发布到 source/_posts

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;front-matter&#34;&gt;Front - matter&lt;/h3&gt;

&lt;p&gt;Front-matter 是文件最上方以 &lt;code&gt;---&lt;/code&gt; 分隔的区域，用于指定个别文件的变量.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title: 使用hexo写作
date: 2016-12-09 16:23:11
categories: 
- Hexo
tags:
- Hexo
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;预定参数如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;layout&lt;/td&gt;
&lt;td&gt;布局&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;title&lt;/td&gt;
&lt;td&gt;标题&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;date&lt;/td&gt;
&lt;td&gt;建立日期&lt;/td&gt;
&lt;td&gt;文件建立日期&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;updated&lt;/td&gt;
&lt;td&gt;更新日期&lt;/td&gt;
&lt;td&gt;文件更新日期&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;comments&lt;/td&gt;
&lt;td&gt;开启文章的评论功能&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tags&lt;/td&gt;
&lt;td&gt;标签（不适用于分页）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;categories&lt;/td&gt;
&lt;td&gt;分类（不适用于分页）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;permalink&lt;/td&gt;
&lt;td&gt;覆盖文章网址&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;更多命令语法参考&lt;a href=&#34;https://hexo.io/zh-cn/docs/&#34;&gt;Hexo 文档&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
  </channel>
</rss>